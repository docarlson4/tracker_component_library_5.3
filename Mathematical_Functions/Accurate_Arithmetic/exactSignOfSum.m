function sgn=exactSignOfSum(S)%EXACTSIGNOFSUM Compute the exact sign of the sum of a number of finite%               numbers. The sign computation occurs exactly, regardless%               of whether the actual sum value would have overflowed or%               suffered an accumulation of finite precision errors%               whereby just adding them would have given the wrong%               result.%%INPUTS: S An NX1 or 1XN vector whereby one desires the sign of the sum of%          the elements.%%OUTPUTS: sgn This is 1 if the exact sum of the elements of S is%             positive, 0 if it is zero and -1 if it is negative.%%The algorithm is taken from [1], where code is provided in an appendix.%The code with minor changes and corrections is also available from Jon%Rokne's web site at http://pages.cpsc.ucalgary.ca/~rokne/%The implementation here uses the corrections and uses the sort algorithm%in Matlab (or the C++ standard template library for the C++%implementation) rather than the sort algorithm provided by Rokne.%%REFERENCES:%[1] H. Ratschek and J. Rokne, "Exact computation of the sign of a finite%    sum," Applied Mathematics and Computation, vol. 99, no. 2-3, pp. 99-%    127, 15 Mar. 1999.%%August 2020 David F. Crouse, Naval Research Laboratory, Washington D.C.%(UNCLASSIFIED) DISTRIBUTION STATEMENT A. Approved for public release.    numInS=length(S);    %%Initialization of the lists a and b.    a=zeros(numInS+3,1);    b=zeros(numInS+3,1);        %Split S into positive and negative summands.    n=0;    m=0;    for i=1:numInS         if(S(i)>0)            m=m+1;            a(m)=S(i);        elseif(S(i)<0)            n=n+1;            b(n)=-S(i);        end    end        %Convert the lists a and b into heaps in descending order.    if(m>1)        a(1:m)=sort(a(1:m),'descend');    end    if(n>1)        b(1:n)=sort(b(1:n),'descend');    end    %The Main loop (the proper ESSA algorithm)    while(1)        %Step 1: (Termination Criteria)        if(n==0&&m==0)            sgn=0;            return;        elseif(n==0||(a(1)>n*b(1)&&m>0))            sgn=1;            return;        elseif(m==0||(b(1)>m*a(1)&&n>0))            sgn=-1;            return;        end        %Step 2: (Auxiliary variables)        as=0;        ass=0;        bs=0;        bss=0;        %Step 3: (Compare and process the leading list )        %Compute the exponent E from a[1] and F from b[1] with respect to        %base 2. a(1)-2^E*(b(1)-2^F) zeros the first bit of a(1) and        %(b(1)).        [~,E]=log2(a(1));        E=E-1;        [~,F]=log2(b(1));        F=F-1;        %E contains the exponent of a(1) and F contains the exponent of        %b(1) in base 2.        if(E==F)%Step 3, case (i):            if(a(1)>=b(1))                as=a(1)-b(1);            else                bs=b(1)-a(1);            end        elseif(E>F)%Step 3, case (ii):            uu=pow2(F);            if(b(1)==uu)                u=uu;            else                u=2*uu;            end            as=a(1)-u;            ass=u-b(1);        elseif(F>E)%Step 3, case (iii):            uu=pow2(E);            if(a(1)==uu)                v=uu;            else                v=2*uu;            end            bs=b(1)-v;            bss=v-a(1);        end        %Step 4: Rearrange of the lists keeping S constant.        if(as==0)            if(ass==0)                a(1)=a(m);                m=m-1;            else                a(1)=ass;            end            a=BuildHeapFromTop(m,a);        else            a(1)=as;            a=BuildHeapFromTop(m,a);            if(ass~=0)                m=m+1;                a(m)=ass;                   a=BuildHeapFromBelow(m,a);            end        end        if(bs==0)            if(bss==0)                b(1)=b(n);                n=n-1;            else                b(1)=bss;            end            b=BuildHeapFromTop(n,b);        else            b(1)=bs;            b=BuildHeapFromTop(n,b);            if(bss~=0)                n=n+1;                b(n)=bss;                b=BuildHeapFromBelow(n,b);            end        end    endend%Helper functions for ordering things.function ra=BuildHeapFromTop(n,ra)    i=1;    top=ra(1);    while(2*i<=n)        m=2*i;        if(ra(m)<ra(m+1))            if(m<n)                m=m+1;            end        end        if(top<ra(m))            ra(i)=ra(m);            i=m;        else            break;        end    end    ra(i)=top;endfunction ra=BuildHeapFromBelow(n,ra)    i=n;    last=ra(n);     while(fix(i/2)>0)        m=fix(i/2);        if(ra(m)<last)            ra(i)=ra(m);            i=m;        else            break;        end    end    ra(i)=last;end%LICENSE:%%The source code is in the public domain and not licensed or under%copyright. The information and software may be used freely by the public.%As required by 17 U.S.C. 403, third parties producing copyrighted works%consisting predominantly of the material produced by U.S. government%agencies must provide notice with such work(s) identifying the U.S.%Government material incorporated and stating that such material is not%subject to copyright protection.%%Derived works shall not identify themselves in a manner that implies an%endorsement by or an affiliation with the Naval Research Laboratory.%%RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF THE%SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY THE NAVAL%RESEARCH LABORATORY FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE ACTIONS%OF RECIPIENT IN THE USE OF THE SOFTWARE.